{"version":3,"file":"string-encode.min.js","sources":["../string-encode.js"],"sourcesContent":["/*requires Uint8Array*/\n/*globals escape, unescape, encodeURI, decodeURIComponent, btoa*/\n\nexport const chr = String.fromCharCode;\n\nexport function ord(chr) {\n    return chr.charCodeAt(0);\n}\n\nexport function buffer2bin(buf) {\n    buf = view8(buf);\n    return chr.apply(String, buf);\n}\n\nexport function buffer2hex(buf) {\n    const bpe = buf.BYTES_PER_ELEMENT << 1;\n    return buf.reduce((r, c) => r += (c >>> 0).toString(16).padStart(bpe,'0'), '');\n}\n\nexport function buffer2str(buf, asUtf8) {\n    if(typeof buf == 'string') return buf;\n    buf = buffer2bin(buf);\n    if (asUtf8 !== false && !isASCII(buf)) {\n        if(asUtf8) {\n            buf = utf8Decode(buf);\n        } else if(asUtf8 == undefined) {\n            try {\n                buf = utf8Decode(buf);\n            } catch(err) {}\n        }\n    }\n    return buf;\n}\n\nexport function str2buffer(str, asUtf8) {\n    if(asUtf8 == undefined) {\n        // Some guessing\n        asUtf8 = hasMultibyte(str); // || !isASCII(str)\n    }\n    if (asUtf8) {\n        str = utf8Encode(str);\n    }\n    return new Uint8Array(String(str).split('').map(ord));\n}\n\nconst nonHexDigitRE = /[^0-9a-f]/g;\n\n/**\n * Read a hex string into a buffer (Uint8Array), ignoring non-hex chars.\n *\n * @param   {String}  str\n *\n * @return  {Uint8Array}\n */\nexport function hex2buffer(str) {\n    str = str.replace(nonHexDigitRE, '');\n    let len = str.length;\n    let ret = new Uint8Array((len + 1) >>> 1);\n\n    for(let i=0; i<len; i+=2) {\n        ret[i >>> 1] = parseInt(str.slice(i, i+2), 16);\n    }\n\n    return ret;\n}\n\n/**\n * This method is a replacement of Buffer.toString(enc)\n * for Browser, where Buffer is not available.\n *\n * @param   {String}  enc  'binary' | 'hex' | 'base64' | 'utf8' | undefined\n *\n * @return  {String}\n */\nexport function toString(enc) {\n    // The Node.js equivalent would be something like:\n    // if(typeof Buffer == 'function') {\n    //     if(enc === false) enc = 'binary';\n    //     if(enc === true) enc = 'utf8';\n    //     return Buffer.from(this.buffer, this.byteOffset, this.byteLength).toString(enc);\n    // }\n    switch(enc) {\n        case false:\n        case 'binary': return buffer2bin(this);\n        case 'hex': return buffer2hex(this);\n        case 'base64': return btoa(buffer2bin(this));\n        case 'utf8': enc = true; break;\n    }\n    return buffer2str(this, enc);\n}\n\nexport function view8(buf, start, len) {\n    // If buf is a Buffer, we still want to make it an Uint8Array\n    if(!start && !len && buf instanceof Uint8Array && !buf.copy) return buf;\n    start = start >>> 0;\n    if(len == undefined) len = buf.byteLength - start;\n    return new Uint8Array(buf.buffer, buf.byteOffset+start, len);\n}\n\nlet _isLittleEndian;\nexport function isLittleEndian() {\n    if(_isLittleEndian != undefined) return _isLittleEndian;\n    _isLittleEndian = !!(new Uint8Array(new Uint16Array([1]).buffer)[0]);\n    isLittleEndian = () => _isLittleEndian;\n    return _isLittleEndian;\n}\n\nexport function switchEndianness32(i) {\n    return (i&0xFF)<<24\n        | (i&0xFF00)<<8\n        | i>>8&0xFF00\n        | i>>24&0xFF\n    ;\n}\n\nexport function guessEncoding(str) {\n    if(hasMultibyte(str)) return 'mb';\n\n    // @todo: test which is faster, utf8bytes() or RegExp\n    // if(isASCII(str)) return 'ascii';\n    // if(isUTF8(str)) return 'utf8';\n\n    let mbLen = utf8bytes(str);\n    if(mbLen) return 'utf8';\n    if(mbLen === 0) return 'ascii';\n    if(mbLen === false) {\n        mbLen = utf8bytes(str, true);\n        if(mbLen) return '~utf8'; // UTF8, but with async characters at the edges\n    }\n    return 'binary';\n}\n\nconst hasMultibyteRE = /([^\\x00-\\xFF])/;\nconst isASCIIRE = /^[\\x00-\\x7F]*$/;\nconst isUTF8RE = /^(?:[\\x00-\\x7F]|[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF][\\x80-\\xBF]|[\\xF0-\\xF7][\\x80-\\xBF][\\x80-\\xBF][\\x80-\\xBF])*$/;\n\nexport function hasMultibyte(str) {\n    let m = hasMultibyteRE.exec(str);\n    return m ? m[1] : false;\n}\n\nexport function isBinary(str) {\n    return !hasMultibyte(str);\n}\n\nexport function isASCII(str) {\n    return isASCIIRE.test(str);\n}\n\nexport function isUTF8(str) {\n    return isUTF8RE.test(str);\n}\n\nexport function utf8bytes(str, allowAsyncChars) {\n    var l = str.length\n    ,   i = 0\n    ,   u = 0\n    ,   c\n    ,   a = -1\n    ,   asy = +!!allowAsyncChars\n    ;\n\n    for( ; i < l ; ) {\n        c = str.charCodeAt(i++);\n        if( c < 0x80 ) continue; // ASCII\n        if( 0xFF <= c ) return false; // has multi-byte\n\n        // async UTF8 character\n        if( (c & 0xC0) == 0x80 ) {\n            // Ignore async UTF8 characters at the beginning\n            if(asy == i) {\n                ++u;\n                ++asy;\n                continue;\n            }\n            return false;\n        }\n\n        // Check sync UTF8 bytes\n        a   = (c & 0xE0) !== 0xC0\n            ? (c & 0xF0) !== 0xE0\n            ? (c & 0xF8) !== 0xF0\n            ? false\n            : 3\n            : 2\n            : 1\n        ;\n        if(!a) return false; // Not an ASCII, nor sync UTF8 bytes\n\n        for( ; (u += 1) && a-- && i < l; ) {\n            c = str.charCodeAt(i++);\n            if((c & 0xC0) !== 0x80) {\n                return false; // Not an ASCII, nor sync UTF8 bytes\n            }\n        }\n    }\n\n    // Ignore async UTF8 characters at the end\n    if(~a && !allowAsyncChars) return false;\n\n    return u;\n}\n\nexport function utf8Encode(str) {\n    return unescape(encodeURI(str));\n}\n\nexport function utf8Decode(str) {\n    return decodeURIComponent(escape(str));\n}\n"],"names":["chr","String","fromCharCode","ord","charCodeAt","buffer2bin","buf","view8","apply","buffer2hex","bpe","BYTES_PER_ELEMENT","reduce","r","c","toString","padStart","buffer2str","asUtf8","isASCII","utf8Decode","undefined","err","nonHexDigitRE","start","len","Uint8Array","copy","byteLength","buffer","byteOffset","_isLittleEndian","isLittleEndian","Uint16Array","hasMultibyteRE","isASCIIRE","isUTF8RE","hasMultibyte","str","m","exec","test","utf8bytes","allowAsyncChars","l","length","i","u","a","asy","utf8Encode","unescape","encodeURI","decodeURIComponent","escape","mbLen","replace","ret","parseInt","slice","split","map","enc","this","btoa"],"mappings":"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"}